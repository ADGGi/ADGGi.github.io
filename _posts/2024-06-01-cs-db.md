---
layout: post
title: "[CS정리]데이터베이스"
date: 2024-06-01 20:00:00 +0900
categories: [CS, DB]
tags: [CS, DB]
author: "ADG"
---

## 데이터베이스의 특징

> **1. 실시간 접근성(Real-Time Accessibility)**  
> 데이터베이스는 실시간으로 데이터를 조회하고 처리할 수 있어야 합니다.  
> **2. 지속적인 변화(Continuous Evolution)**  
> 데이터베이스는 새로운 데이터의 삽입(INSERT),삭제(DELETE),갱신(UPDATE) 등을 통해 항상 최신 상태를 유지해야 합니다.  
> **3. 동시 공용(Concurrent Sharing)**  
> 데이터베이스는 여러 사용자가 동시에 데이터를 안전하게 사용할 수 있어야 하며, 데이터에 대한 접근 충돌을 방지해야 합니다.  
> **4. 내용에 의한 참조(Content Reference)**  
> 데이터를 참조할 때 물리적인 주소나 위치가 아닌, 데이터의 내용에 따라 데이터를 찾을 수 있습니다.

## 데이터베이스 언어

> **1. DDL(정의어, Data Definition Language)**  
> 데이터베이스 구조를 정의, 수정, 삭제하는 언어  
> `ALTER`,`CREATE`,`DROP`,`TRUNCATE`,`RENAME`  
> **2. DML(조작어, Data Manipulation Language)**  
> 데이터베이스의 조회, 삽입, 갱신, 삭제를 위한 언어로 저장된 데이터를 조작하는 역할 수행  
> `SELECT`,`INSERT`,`UPDATE`,`DELETE`  
> **3. DCL(제어어, Data Control Language)**  
> 데이터베이스의 접근 권한을 제어하여 사용자 권한관리를 수행하여 시스템 보안을 유지하는 역할 수행  
> `GRANT`,`REVOKE`  
> **4. TCL(트랜잭션 제어어, Transaction Control Language)**  
> DCL에서 트랜잭션을 제어하는 명령어로 DCL에 포함된다.  
> `COMMIT`,`ROLLBACK`,`SAVEPOINT`  

## SELECT 쿼리의 수행 순서

**`FROM`**,**`ON`**,**`JOIN`** -> **`WHERE`**, **`GROUP BY`**, **`HAVING`** -> **`SELECT`** -> **`DISTINCT`** -> **`ORDER BY`** -> **`LIMIT`**

 ```sql
 SELECT
     c.customer_id,
     c.customer_name,
     COUNT(o.order_id) AS total_orders,
     SUM(o.amount) AS total_spent
 FROM
     customers c
 JOIN
     orders o ON c.customer_id = o.customer_id
 WHERE
     c.status = 'active'
     AND o.order_date >= '2024-01-01'
 GROUP BY
     c.customer_id, c.customer_name
 HAVING
     COUNT(o.order_id) > 5
 ORDER BY
     total_spent DESC
 LIMIT 10;
 ```

**1. FROM**  
- customers 테이블을 선택하여 데이터를 가져옵니다.  
- `JOIN` 을 통하여 customers 테이블과 orders 테이블을 c.customer_id = o.customer_id로 연결합니다.  

**2. ON**  
- `JOIN` 조건 처리를 위해 orders 테이블에서 각 customer_id가 customers 테이블의 customer_id 와 일치하는 레코드를 결합합니다.  

**3. JOIN**  
- customers 테이블과 orders 테이블이 결합되어 새로운 데이터셋을 만듭니다.  
- 이 때 결합되는 레코드는 ON 절에 정의된 조건 (c.customer_id = o.customer_id)을 만족하는 데이터만 결합됩니다.  
- 각 customer_id가 일치하는 customer와 order 정보만 결합되어 새로운 데이터셋이 생성됩니다.  

**4. WHERE**  
- `WHERE` 조건이 적용되어 결합된 데이터셋에서 customers 테이블의 status가 'active'인 고객만 필터링하고, orders 테이블에서 order_date가 2024년 1월 1일 이후인 레코드만 남게됩니다.  

**5. GROUP BY**  
- `WHERE` 절 조건이 적용된 레코드에 대해 `GROUP BY` 가 적용됩니다.  customer_id와 customer_name을 기준으로 데이터를 그룹화하고, 각 그룹에 대한 집계를 수행합니다.  

**6. HAVING**  
- `GROUP BY` 절에 의해 집계가 된 이후 각 그룹에 대해 COUNT(o.order_id) > 5 인 그룹만 남게됩니다. 즉, 주문이 5개 이상인 고객만 선택합니다.  

**7. SELECT**  
- customer_id, customer_name, total_orders, total_spent 컬럼만을 최종 선택합니다.  

**8. DISTINCT**  
- 해당 예시에서는 `DISTICNT`가 없으므로 수행하지 않고 건너뜁니다.  

**9. ORDER BY**  
- total_spent 기준으로 내림차순 정렬이 수행됩니다.  

**10. LIMIT**  
- `LIMIT 10` 절이 적용되어 내림차순 10개(많은 지출 순서대로 10번째까지)의 레코드가 반환됩니다.  

## 조인(JOIN)

- 조인(JOIN)은 여러 테이블에서 데이터를 결합하여 하나의 결과 집합을 만드는 SQL 연산입니다. 조인은 일반적으로 관계형 데이터베이스에서 두 개 이상의 테이블을 연결할 때 사용됩니다.

`employees` 테이블

| employee_id | name    | department_id |
| ----------- | ------- | ------------- |
| 1           | Alice   | 101           |
| 2           | Bob     | 102           |
| 3           | Charlie | 103           |
| 4           | David   | 101           |
| 5           | Eve     | NULL          |

---

`departments` 테이블

| department_id | department_name |
| ------------- | --------------- |
| 101           | HR              |
| 102           | IT              |
| 103           | Marketing       |
| 104           | Finance         |

---

**1. INNER JOIN**
> - 테이블 간에 일치하는 값이 있을 경우에만 결과를 반환합니다.
> - 테이블에서 같은 키 값을 가진 행만 결합할 때 사용됩니다.
> 
> ```sql
> SELECT e.name, d.department_name
> FROM employees e
> INNER JOIN departments d ON e.department_id = d.department_id;
> ```
> 
> | name    | department_name |
> | ------- | --------------- |
> | Alice   | HR              |
> | Bob     | IT              |
> | Charlie | Marketing       |
> | David   | HR              |
> 

**2. OUTER JOIN**
> - `LEFT OUTER JOIN`은 왼쪽테이블의 모든 레코드를 반환합니다.
> - `RIGHT OUTER JOIN`은 오른쪽테이블의 모든 레코드를 반환합니다.
> - `FULL OUTER JOIN`은 왼쪽테이블과 오른쪽테이블의 모든 행을 결합하여 반환합니다.
> 
> ```sql
> SELECT e.name, d.department_name
> FROM employees e
> LEFT OUTER JOIN departments d ON e.department_id = d.department_id;
> ```
> 
> | name    | department_name |
> |---------|-----------------|
> | Alice   | HR              |
> | Bob     | IT              |
> | Charlie | Marketing       |
> | David   | HR              |
> | Eve     | NULL            |
> 
> ---
> 
> ```sql
> SELECT e.name, d.department_name
> FROM employees e
> RIGHT OUTER JOIN departments d ON e.department_id = d.department_id;
> ```
> 
> | name    | department_name |
> |---------|-----------------|
> | Alice   | HR              |
> | Bob     | IT              |
> | Charlie | Marketing       |
> | David   | HR              |
> | NULL    | Finance         |
> 
> ---
> 
> ```sql
> SELECT e.name, d.department_name
> FROM employees e
> FULL OUTER JOIN departments d ON e.department_id = d.department_id;
> ```
> 
> | name    | department_name |
> |---------|-----------------|
> | Alice   | HR              |
> | Bob     | IT              |
> | Charlie | Marketing       |
> | David   | HR              |
> | Eve     | NULL            |
> | NULL    | Finance         |
> 

**3. CROSS JOIN**
> - CROSS JOIN은 데카르트 곱(Certesian Product)라고도 불리며, 두 테이블의 모든 조합을 반환하는 조합입니다. 즉, 왼쪽테이블의 각 행이 오른쪽 테이블의 모든 행과 결합됩니다.
>
> ```sql
> SELECT e.name, d.department_name
> FROM employees e
> CROSS JOIN departments d;
> ```
> 
> | name    | department_name |
> |---------|-----------------|
> | Alice   | HR              |
> | Alice   | IT              |
> | Alice   | Marketing       |
> | Alice   | Finance         |
> | Bob     | HR              |
> | Bob     | IT              |
> | Bob     | Marketing       |
> | Bob     | Finance         |
> | Charlie | HR              |
> | Charlie | IT              |
> | Charlie | Marketing       |
> | Charlie | Finance         |
> | David   | HR              |
> | David   | IT              |
> | David   | Marketing       |
> | David   | Finance         |
> | Eve     | HR              |
> | Eve     | IT              |
> | Eve     | Marketing       |
> | Eve     | Finance         |

## 트리거(Trigger)

- 트리거는 특정 테이블에 대한 이벤트에 반응하여 DML(INSERT, UPDATE, DELETE)문이 실행될 때 데이터베이스에서 자동으로 동작하는 프로그램입니다.  
- 사용자가 직접 호출하는 것이 아니라 데이터베이스가 자동으로 호출합니다.  
- 트리거는 데이터의 무결성 유지를 위한 자동화 작업이나 특정 작업의 수행을 위해 사용됩니다.  

> **1. BEFORE 트리거**  
> 데이터가 변경되기 전에 실행됩니다. 데이터를 수정하기 전에 필터링 하거나 데이터를 자동으로 변경하는 등의 작업을 수행할 수 있습니다.  
> 예시)`INSERT`나 `UDPATE` 작업 전, 데이터를 검증하거나 기본값을 설정하는 데 사용됩니다.  
> 예시) 사용자가 이메일 주소를 `UPDATE` 할 때 이메일 주소가 올바른 형식인지 확인하거나, 특정 조건을 만족하는 경우에만 데이터를 변경하도록 제한합니다.  
>  
> **2. AFTER 트리거**  
> 데이터가 변경된 후에 실행됩니다. 데이터가 삭제된 후에 로그를 기록하거나, 다른 테이블에 업데이트를 수행하는 드으이 작업을 할 수 있습니다.  
> 예시) `DELETE` 수행 후 삭제된 데이터를 다른 테이블에 백업하거나 시스템 로그에 기록하는 작업을 할 때 사용됩니다.  
>  
> **3. INSTEAD OF 트리거**  
> 트리거가 발생한 동작을 대신하여 다른 작업을 수행합니다. 일반적으로 `INSERT`,`UPDATE`,`DELETE`와 같은 DML 작업에서 사용됩니다.  
> 예시) 뷰(View)에 대해 `INSERT`,`UPDATE`,`DELETE` 작업이 발생할 때, INSTEAD OF 트리거를 사용하여 실제 테이블에 대한 작업을 수행할 수 있습니다.  
> 예시) 예를 들어, 뷰에서 데이터를 INSERT하려고 할 때, INSTEAD OF 트리거가 호출되어 실제 테이블에 대한 `INSERT`작업을 대신 수행할 수 있습니다.  
>   
> **4. DML 트리거**  
> `INSERT`,`UPDATE`,`DELETE`와 같은 DML(데이터 조작 언어) 명령어에 대한 트리거입니다. 데이터베이스의 데이터를 수정, 삽입, 삭제하는 작업에 대한 반응으로 트리거가 실행됩니다.  
> 예시) 데이터 삽입 전, 데이터가 유효한지 확인 하거나 데이터 삭제 후에 로그 기록을 하는 등의 작업을 진행 할 수 있습니다.  
>  
> **5. DDL 트리거**  
> 데이터 정의 언어(DDL) 명령어인 `CREATE`, `ALTER`, `DROP` 등에 대해 트리거가 실행됩니다. DDL 트리거는 테이블 구조를 변경하는 명령어에 대해 반응할 때 사용됩니다.  
> 예시) 데이터베이스 구조의 변경이 일어날 때마다 감사 로그를 기록하거나, 특정 권한을 부여하는 등의 작업을 할 수 있습니다.  
>  
> **6. LOGON/LOGOFF 트리거**  
> 데이터베이스에 로그인하거나 로그아웃할 때 실행되는 트리거입니다.  
> 예시) 사용자가 데이터베이스에 로그인할 때 감사 로그를 기록하거나, 로그아웃할 때 세션정보를 정리하는 작업을 할 수 있습니다.  
  
## 인덱스(INDEX)

인덱스는 테이블 내의 데이터를 빠르게 검색하기 위해 사용하는 데이터 구조입니다. 인덱스는 검색 성능을 향상시키지만, 쓰기 성능(삽입, 갱신, 삭제)에 영향을 미칠 수 있습니다.
- 장점: 검색 속도 향상
- 단점: 인덱스를 유지하기 위한 추가적인 저장 공간과 쓰기 작업에서 성능 저하

**1. 단일 인덱스(Single Column Index)**  
- 특정 컬럼에 대한 검색 속도를 향상 시킬 수 있습니다.  
- 두개 이상의 컬럼을 결합한 조회,검색 시 성능 최적화를 기대하기 어렵습니다.  

**2. 다중 인덱스(Composite Index)**  
- 조회 조건에 자주 포함되는 여러 컬럼을 기준의 경우 성능을 향상 시킬 수 있습니다.  
- 인덱스 순서가 쿼리 성능에 영향을 미칠 수 있습니다. 예를들어, 주문번호화 주문일자 순서로 생성된 다중 인덱스는 주문일자만을 기준으로 조회할 때는 최적화 되지 않습니다.  

**3. 유니크 인덱스(Unique Index)**  
- 인덱스가 적용된 컬럼의 값이 중복되지 않도록 보장하여 데이터의 무결성을 보장합니다.  
- 유일성 검사와 인덱스 업데이트가 성능에 영향을 미칠 수 있습니다.  

**4. 클러스터 인덱스(Clustered Index)**  
- 테이블의 데이터를 인덱스 순서대로 정렬하여 저장해 범위 검색 시 성능을 향상 시킬 수 있습니다.  
- 데이터가 물리적으로 정렬되므로 데이터 삽입 시 성능 저하가 생깁니다.  

**5. 비클러스터 인덱스(Non-clustered Index)**  
- 테이블의 데이터와 인덱스가 별도로 저장되어 여러 인덱스를 테이블에 추가할 수 있어 다양한 쿼리를 최적화 할 수 있습니다.  
- 인덱스가 테이블과 분리되어 존재하며, 테이블의 각 레코드에 대한 포인터를 포함하고 있습니다. 이 포인터는 실제 테이블의 행을 가리킵니다.  
- 비클러스터 인덱스는 인덱스와 테이블 데이터가 별도로 저장되기 떄문에, 인덱스 검색 후 실제 데이터가 저장된 위치를 찾아야 합니다. 이로 인해 인덱스 조회 후 실제 데이터에 접근 하기 위한 추가적인 I/O가 발생할 수 있습니다. 즉, 인덱스만 조회할 수 있는 클러스터 인덱스에 비해 조회 속도가 느릴 수 있습니다.  
- 인덱스 여러개를 동시에 생성할 수 있어 다양한 쿼리 조건을 최적화 할 수 있지만, 많은 인덱스가 존재할 수록 DML 작업 후 설정된 인덱스를 모두 갱신해야 하기 때문에 성능이 더욱 떨어질 수 있습니다.  
- `BETWEEN`, `>`, `<` 등의 범위 검색 에서 비클러스터 인덱스는 데이터를 찾아가야 하는 추가 단계가 필요하므로 비효율적으로 실행됩니다.

## 인덱스 자료구조

**1. B-Tree (Balanced Tree)**
> - B-Tree는 균형 이진 트리(balanced binary tree)로, 모든 리프 노드가 동일한 깊이에 있습니다.
> - 각 노드는 키 값과 포인터를 포함하고, 노드는 자식 노드들을 가리키는 링크를 포함합니다.
> - 루트에서 리프 노드까지의 거리가 일정하므로, 검색(탐색), 삽입, 삭제 연산 모두 `O(logN)` 시간복잡도를 가집니다.
> - 트리의 높이가 logN 에 비례하므로 검색 시 트리의 깊이를 따라가면 되므로 `O(logN)` 시간이 소요됩니다.
> - 새 데이터를 삽입할 때 트리의 균형을 맞추고 올바른 위치를 찾아 삽입하기 위해 `O(logN)` 시간이 소요됩니다.
> - 데이터를 삭제할 때도 군형을 맞춰야 하므로 `O(logN)` 시간이 소요됩니다.
> - 모든 연산에서 `O(logN)`의 시간복잡도를 가집니다.
> 
> 장점
> - 검색 속도가 빠르며, 범위 검색에 적합합니다.
> - 균형 트리이므로 탐색, 삽입, 삭제에 대해 일정한 성능을 보장합니다.
> - 인덱스를 만들 때 테이블 데이터를 정렬된 상태로 유지합니다.
>
> 단점
> - 데이터 변경 시 오버헤드가 발생합니다. (특히 삽입과 삭제 시 트리의 균형을 맞추는 데 시간이 필요)
> - 범위 검색에서는 다양한 범위를 처리할 때 성능이 뛰어나지만, 단일 값 검색에서는 해시 기반 인덱스에 비해 성능이 떨어질 수 있습니다.

**2. B+ Tree**
> - B+ Tree는 B-Tree의 변형으로, 리프 노드를 연결리스트(Linked List)로 연결하여 범위 검색 성능을 개선한 자료구조입니다.
> - B+ Tree 내부 노드는 키 값만 저장하고, 리프 노드는 실제 데이터 포인터를 저장합니다.
> - 리프 노드들은 순차적으로 연결되어 있어 범위 검색시 빠르게 연속된 데이터를 읽을 수 있습니다.
> - 모든 연산에서 `O(logN)`의 시간 복잡도를 가집니다.
> 
> 장점
> - 범위 검색에 최적화 되어 있으며, 순차 접근이 빠릅니다.
> - 리프 노드가 연결되어 있어 범위 검색 시 연속된 데이터에 빠르게 접근할 수 있습니다.
> - 데이터 크기가 커질수록 효율적이며, 검색 성능이 일정합니다.
>
> 단점
> - 삽입, 삭제 시 트리 균형을 맞추기 위해 리빌드가 필요합니다.
> - 트리의 내부 노드가 많을 경우, 메모리 사용량이 많아질 수 있습니다.

**3. Hash Index**
> - 정확히 일치하는 값을 검색할 때 매우 빠른 성능을 가지는 자료구조입니다.
> - 키 값을 해시 함수에 넣고, 결과 해시 값을 이용하여 데이터 위치를 찾습니다.
> - 정확한 일치 값 검색에 대해 `O(1)`의 시간 복잡도를 가집니다.
>
> 장점
> - 일치하는 값을 검색할 때 적합합니다. 등호 조건 검색이 매우 빠릅니다.
> - 간단한 구조로 저장 공간을 적게 차지합니다.
>
> 단점
> - 범위 검색에는 사용할 수 없습니다.
> - 데이터가 추가되거나 수정될 때, 해시 값을 재계산 하므로 성능에 영향을 미칠 수 있습니다.
> - 충돌 처리가 필요합니다. 해시 충돌이 발생하면 체이닝, 오픈어드레싱 등의 추가적인 메커니즘이 필요합니다.

## 정규화(Normalization)

정규화(Normalization)는 관계형 데이터베이스에서 데이터의 중복을 줄이고, 데이터의 무결성을 유지하기 위해 사용하는 과정입니다. 정규화는 데이터베이스 설계 단계에서 중요한 역할을 하며, 여러 개의 규칙(정규형)을 따릅니다. 각 정규형은 데이터를 어떻게 조직하고, 테이블을 분할할지에 대한 지침을 제공합니다.
정규화의 목표는 중복 데이터 제거, 데이터 무결성 보장, 최소한의 데이터 중복으로 성능 최적화를 실현하는 것입니다.

**장점**
- 중복 데이터 제거  
 정규화는 중복 데이터를 최소화하고, 데이터 무결성을 유지합니다. 이를 통해 데이터의 일관성과 정확성을 보장할 수 있습니다.
- 데이터 무결성 향상  
 데이터를 중복 없이 분리하여 저장함으로써 갱신 이상, 삭제 이상, 삽입 이상을 방지할 수 있습니다. 이는 데이터의 일관성 및 정확성을 유지하는 데 중요합니다.
- 저장 공간 절약  
 중복 데이터를 제거하고 테이블을 분리함으로써 저장 공간을 절약할 수 있습니다. 특히 대량의 데이터를 다룰 때 중요한 장점이 됩니다.
- 쿼리 최적화  
 정규화를 통해 데이터를 구조화하면, 쿼리 성능을 향상시킬 수 있습니다. 잘 정리된 데이터는 인덱스를 잘 활용할 수 있어 검색 속도를 향상시킵니다.
- 유지 보수 용이  
 데이터베이스 구조가 명확하고 잘 구조화되어 있으면, 데이터베이스의 유지보수와 업데이트가 용이해집니다. 테이블 간 관계가 명확하게 정의되어 있기 때문에, 데이터 변경 시 오류를 줄일 수 있습니다.

**단점**
- 복잡한 쿼리  
 정규화가 지나치게 진행되면, 데이터를 여러 테이블로 분리하게 됩니다. 이로 인해 조인 연산이 많아져 쿼리가 복잡해지고, 성능이 저하될 수 있습니다. 특히 복잡한 비즈니스 로직을 처리할 때 쿼리가 느려질 수 있습니다.
- 데이터 삽입, 갱신, 삭제의 비용 증가  
 정규화된 구조에서는 데이터가 여러 테이블에 분리되어 있기 때문에, 데이터 삽입, 갱신, 삭제 시 여러 테이블에 대해 작업을 해야 하므로 DML(데이터 조작 언어) 작업의 비용이 커질 수 있습니다.
- 과도한 정규화  
 과도한 정규화는 데이터 모델을 너무 세분화하여 이해하기 어려운 구조가 될 수 있습니다. 너무 많은 테이블을 만들면, 데이터베이스를 관리하거나 이해하는 데 어려움이 있을 수 있습니다.
- 인덱스 및 저장소 사용 증가  
 정규화된 데이터는 여러 테이블로 나누어져 저장되므로, 인덱스를 추가하거나 저장소를 효율적으로 관리하는 데 추가적인 리소스가 필요할 수 있습니다. 이로 인해 저장소 관리가 복잡해질 수 있습니다.

**1. 제1정규형(1NF, First Normal Form)**
>규칙
>- 원자성 : 각 테이블의 셀은 하나의 값을 가져야 합니다.
>- 컬럼에 여러 값이 들어가는 것을 허용하지 않습니다.
>
>예시)
>
>| ID  | Name  | PhoneNumbers       |
>| --- | ----- | ------------------ |
>| 1   | John  | 123-4567, 987-6543 |
>| 2   | Alice | 555-1234           |
>
>위 테이블은 **1NF를 위반**합니다. `PhoneNumbers`에 여러 개의 전화번호가 들어가 있기 때문입니다.  
>
>1NF로 정리:
>
>| ID  | Name  | PhoneNumber |
>| --- | ----- | ----------- |
>| 1   | John  | 123-4567    |
>| 1   | John  | 987-6543    |
>| 2   | Alice | 555-1234    |

**2. 제2정규형(2NF, Second Normal Form)**
> 규칙
> - 기본 키가 여러 컬럼으로 이루어져 있는 경우, 모든 비기본속성(컬럼)은 기본키 전체에 종속적이어야 합니다.
> - 기본 키의 일부 컬럼에만 의존하는 컬럼은 별도의 테이블로 분리해야 합니다.
> 
> 예시)
> 
> | StudentID | CourseID | Instructor  |
> |-----------|----------|-------------|
> | 1         | CS101    | Prof. A     |
> | 1         | MATH201  | Prof. B     |
> | 2         | CS101    | Prof. A     |
> 
> 위 테이블에서는 StudentID, CourseID가 복합 기본 키이고, Instructor는 CourseID에만 의존하고 있습니다. 즉, Instructor는 CourseID에 종속되어 있고, StudentID에는 종속되지 않습니다. 이는 부분적 종속성을 발생시킵니다.
>
> 2NF로 정리:
> 1. 학생과 수업 정보를 분리하여, 학생별 수업 정보를 저장하는 테이블과 수업별 강사 정보를 저장하는 테이블로 나눕니다.
> 
> 학생 수업 정보 테이블:
> 
> | StudentID | CourseID |
> |-----------|----------|
> | 1         | CS101    |
> | 1         | MATH201  |
> | 2         | CS101    |
> 
> 수업 강사 정보 테이블:
> 
> | CourseID  | Instructor  |
> |-----------|-------------|
> | CS101     | Prof. A     |
> | MATH201   | Prof. B     |

**3. 제3정규형(3NF, Thrid Normal Form)**
> 규칙
> - 비기본 속성이 다른 비기본 속성에 의존하는 경우 이를 별도의 테이블로 분리해야 합니다.
> - 이행적 함수 종속을 없애도록 분해하는 것을 의미합니다. (A->B,B->C가 성립할 때 A->C가 성립)
> 
> 예시)
> 
> | EmployeeID | DepartmentID | DepartmentName |
> |------------|--------------|----------------|
> | 101        | 10           | HR             |
> | 102        | 20           | IT             |
> 
> 여기에서 DepartmentName은 DepartmentID에 의존하고, DepartmentID는 EmployeeID와 함께 기본 키의 일부를 형성합니다. 이는 이행적 종속성입니다. 즉, EmployeeID는 DepartmentName을 간접적으로 결정합니다.
> 
> 3NF로 정리:
> 1. 부서 이름을 부서 테이블로 분리하여 중복을 없앱니다.
> 
> 직원 테이블:
> 
> | EmployeeID | DepartmentID |
> |------------|--------------|
> | 101        | 10           |
> | 102        | 20           |
> 
> 부서 테이블:
> 
> | DepartmentID | DepartmentName |
> |--------------|----------------|
> | 10           | HR             |
> | 20           | IT             |

**4. 보이스-코드 정규형(BCNF, Boyce-Codd Normal Form)**
> 규칙
> - 모든 결정자는 후보키여야 합니다.
> - 하나의 속성이 다른 속성을 결정할 때, 그 속성은 후보키여야 합니다.
> 
> 예시)
> 
> | CourseID | Instructor | Book        |
> |----------|------------|-------------|
> | CS101    | Prof. A    | Database  |
> | CS102    | Prof. B    | Algorithms|
> 
> 여기에서 Instructor가 Book을 결정하고 있습니다. 하지만 Instructor는 후보 키가 아니기 때문에, 이는 BCNF를 위반합니다.
> 
> BCNF로 정리:
> 1. Instructor와 Book을 별도의 테이블로 분리하여 해결합니다.
> 
> 수업 테이블:
> 
> | CourseID | Instructor |
> |----------|------------|
> | CS101    | Prof. A    |
> | CS102    | Prof. B    |
> 
> 도서 테이블:
> 
> | Instructor | Book        |
> |------------|-------------|
> | Prof. A    | Database  |
> | Prof. B    | Algorithms|

**5. 제4정규형(4NF, Fourth Noraml Form)**
> 규칙
> - 다치 종속성을 제거하기 위해, 하나의 테이블에 여러 개의 독립적인 다중 값 속성을 두지 않아야 합니다.
> 
> 예시)
> 
> | StudentID | Course    | Hobby      |
> |-----------|-----------|------------|
> | 1         | CS101     | Reading    |
> | 1         | CS102     | Swimming   |
> 
> 여기에서 StudentID는 Course와 Hobby 모두에 다치 종속성을 가지고 있습니다. 즉, 학생과 관련된 수업과 취미는 독립적인 값들이기 때문에 다치 종속성이 발생합니다.
> 
> 4NF로 정리:
> 1. 수업 정보와 취미 정보를 각각 분리합니다.
> 
> 수업 테이블:
> 
> | StudentID | Course    |
> |-----------|-----------|
> | 1         | CS101     |
> | 1         | CS102     |
> 
> 취미 테이블:
> 
> | StudentID | Hobby     |
> |-----------|-----------|
> | 1         | Reading   |
> | 1         | Swimming  |

**6. 제5정규형 (5NF, Fifth Normal Form)**
> 규칙
> - 조인 종속성을 해결하기 위해, 테이블을 더 작은 테이블로 분할합니다.
> - 조인 종속성이란 특정 테이블을 결합하는 데 사용되는 관계를 의미합니다. 제5정규형에서는 불필요한 조인으로 인한 중복을 없애고, 각 데이터를 보다 세분화하여 저장하는 것이 목표입니다.
> 
> 예시)
> 
> 비정규화된 테이블:
> 
> | StudentID | Course   | Instructor |
> |-----------|----------|------------|
> | 1         | Math     | Prof. A    |
> | 1         | CS101    | Prof. B    |
> | 2         | Math     | Prof. A    |
> | 2         | CS101    | Prof. B    |
> 
> 이 테이블에서는 각 학생(StudentID)에 대해, 여러 개의 과목(Course)과 교수(Instructor) 관계가 존재합니다. 여기에서 과목과 교수는 학생과 독립적인 관계를 가질 수 있습니다. 이 테이블은 제5정규형을 위반하고 있으며, 중복 데이터가 발생할 수 있는 형태입니다.
>
> 5NF로 정리:
> 
> 1. 학생과 과목 관계 테이블:
> 
> | StudentID | Course   |
> |-----------|----------|
> | 1         | Math     |
> | 1         | CS101    |
> | 2         | Math     |
> | 2         | CS101    |
> 
> 2. 학생과 교수 관계 테이블:
> 
> | StudentID | Instructor |
> |-----------|------------|
> | 1         | Prof. A    |
> | 1         | Prof. B    |
> | 2         | Prof. A    |
> | 2         | Prof. B    |
> 
> 3. 과목과 교수 관계 테이블:
> 
> | Course   | Instructor |
> |----------|------------|
> | Math     | Prof. A    |
> | CS101    | Prof. B    |
> 
> 위 예시에서 볼 수 있듯이, 제5정규형에서는 학생(StudentID), 과목(Course), 교수(Instructor)의 관계를 세 개의 테이블로 나누어 중복 데이터를 최소화하고, 각 데이터를 별도로 저장합니다.  
> 이 방식은 데이터를 효율적으로 분리하여, 후속 쿼리 시 중복된 정보를 처리할 필요가 없도록 합니다.  
> 따라서 제5정규형에서는 모든 관계가 독립적이고, 불필요한 중복을 제거하는 구조를 취합니다. 이로 인해 데이터의 정확성과 무결성을 보장할 수 있습니다.

## 트랜잭션(Transaction)

- 트랜잭션은 데이터베이스에서 하나의 작업 단위로, 여러 작업을 하나로 묶어서 **원자성(Atomicity)**, **일관성(Consistency)**, **격리성(Isolation)**, **내구성(Durability)**을 보장하는 작업입니다.
- 여러 데이터베이스 작업이 하나의 트랜잭션으로 묶여서 처리되고, 모든 작업이 정상적으로 완료되면 `commit`하고, 문제가 발생하면 `rollback`하여 이전 상태로 되돌리는 방식으로 데이터 무결성을 지킵니다.
- 트랜잭션의 주요 속성은 **ACID**로 요약됩니다. 이는 트랜잭션이 처리하는 동안 **데이터의 일관성**을 유지하고, **오류**가 발생했을 경우 **복구 가능**하도록 보장하는 원칙입니다.

> **1. 원자성(Atomicity)**
> - 트랜잭션은 **최소 단위**로 처리됩니다. 트랜잭션 내의 모든 연산이 **전부 성공**하거나 **전부 실패**해야 합니다. 중간에 문제가 발생하면 **모든 작업이 취소**됩니다.  
> 
> - 예시: 은행 계좌 이체 시, **송금**과 **입금** 두 작업이 하나의 트랜잭션으로 묶여 있고, 송금만 성공하고 입금이 실패하면 둘 다 취소됩니다.  
> 
> ---
> 
> **2. 일관성(Consistency)**
> - 트랜잭션 시작 전과 끝난 후에 데이터베이스는 **일관성 있는 상태**여야 합니다. 트랜잭션이 완료된 후 데이터가 **정상적이고 규칙에 맞는 상태**여야 합니다.  
> - 예시: 트랜잭션이 종료되었을 때, 은행 계좌의 잔액이 정확히 맞아야 합니다.
>
> ---
>
> **3. 격리성(Isolation)**
>   - 동시에 실행되는 여러 트랜잭션은 서로 **독립적으로 실행**됩니다. 다른 트랜잭션의 작업이 중간에 개입하지 않도록 보장합니다. 격리 수준에 따라 트랜잭션 간의 상호작용 정도가 달라집니다.  
> - 예시: 한 사용자가 트랜잭션을 수행하는 동안 다른 사용자는 그 트랜잭션이 끝날 때까지 그 데이터를 볼 수 없습니다.
>
> ---
>
> **4. 내구성(Durability)**
>   - 트랜잭션이 **완료(commit)**된 후에는, 시스템 장애가 발생하더라도 트랜잭션의 결과가 **영구적으로 저장**됩니다. 트랜잭션이 성공적으로 끝났다면 그 결과는 언제나 보존됩니다.  
> - 예시: 전자상거래에서 구매가 완료된 후, 서버가 다운되더라도 결제 내역은 보존되어야 합니다.