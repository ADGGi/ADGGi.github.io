---
layout: post
title: "[백준]1015번 수열정렬(Python3)"
date: 2024-06-06 20:00:00 +0900
categories: [CS, 백준]
tags: [CS, 백준]
author: "ADG"
---

# 문제

P[0], P[1], ...., P[N-1]은 0부터 N-1까지(포함)의 수를 한 번씩 포함하고 있는 수열이다.  
수열 P를 길이가 N인 배열 A에 적용하면 길이가 N인 배열 B가 된다.  
적용하는 방법은 B[P[i]] = A[i]이다.

배열 A가 주어졌을 때, 수열 P를 적용한 결과가 비내림차순이 되는 수열을 찾는 프로그램을 작성하시오.  
비내림차순이란, 각각의 원소가 바로 앞에 있는 원소보다 크거나 같을 경우를 말한다.  
만약 그러한 수열이 여러개라면 사전순으로 앞서는 것을 출력한다.

---
### 입력

첫째 줄에 배열 A의 크기 N이 주어진다.  
둘째 줄에는 배열 A의 원소가 0번부터 차례대로 주어진다.  
N은 50보다 작거나 같은 자연수이고, 배열의 원소는 1,000보다 작거나 같은 자연수이다.  

---
### 출력

첫째 줄에 비내림차순으로 만드는 수열 P를 출력한다.

---
### 예제입력 1

3  
2 3 1  

---
### 예제출력 1

1 2 0  

---
### 풀이

- 조건정리  
1. 수열 `P`는 배열 `A`를 변형하는 방식  
2. 배열 `B`는 수열 `P`를 배열 `A`에 적용한 결과로, 배열 `B`는 비내림차순이어야 함  
3. 배열 `B`는 `B[P[i]] = A[i]` 로 정의
4. 구해야 하는 것은 배열 `A`의 원소들을 비내림차순으로 만들 수 있게 순서를 결정하는 **수열 `P`**  
5. 만약 여러 해를 가진다면 사전순으로 가장 앞서는 배열 `P`  
6. 즉, `P`는 `A`의 각 원소가 몇번째로 작은지를 나타내는 배열

- 해결과정  
1. 먼저, 배열 `A`의 값을 비내림차순으로 정렬하려면 해당 값들이 원래 배열에서 어디에 위치했는지에 대한 정보가 필요  
2. 배열 `A`의 각 원소에 대해 (값, 인덱스) 형태로 튜플을 생성  

```python
N = 3
A = [2, 3, 1]

indexed_A = [(A[i], i) for i in range(N)] # [(2, 0), (3, 1), (1, 2)]
indexed_A.sort() # [(1, 2), (2, 0), (3, 1)]
# A[0] = B[P[0]] = B[1] = 2
# A[1] = B[P[1]] = B[2] = 3
# A[2] = B[P[2]] = B[0] = 1
```

3. 배열 `A`의 값들이 비내림차순으로 정렬되었을 때의 인덱스를 기록하는 배열 `P`를 생성
4. `indexed_A` 배열에서 각 값이 원래 `A`에서 어떤 위치에 있었는지를 기록
5. `indexed_A[i][1]`은 원래 배열 `A`에서 해당 값이 위치했던 인덱스
6. `indexed_A[i][1]`에 해당하는 `P`의 위치에 i를 추가

```python
# 인덱스를 기록할 배열 P
P = [0]*N # N = 3

for i in range(N):
    P[indexed_A[i][1]] = i
```


제출코드

```python
import sys

N = int(sys.stdin.readline())
A = list(map(int, sys.stdin.readline().split()))

indexed_A = [(A[i], i) for i in range(N)]
indexed_A.sort()

P = [-1] * N
for i in range(N):
    P[indexed_A[i][1]] = i
    
print(*P)
```