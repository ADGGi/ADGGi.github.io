---
layout: post
title: "[프로그래머스]PCCP 2번 퍼즐 게임 챌린지(Python3)"
date: 2024-06-12 20:00:00 +0900
categories: [CS, 코딩테스트]
tags: [CS, 프로그래머스]
author: "ADG"
---

# 문제

당신은 순서대로 `n`개의 퍼즐을 제한 시간 내에 풀어야 하는 퍼즐 게임을 하고 있습니다. 각 퍼즐은 난이도와 소요 시간이 정해져 있습니다. 당신의 숙련도에 따라 퍼즐을 풀 때 틀리는 횟수가 바뀌게 됩니다. 현재 퍼즐의 난이도를 `diff`, 현재 퍼즐의 소요 시간을 `time_cur`, 이전 퍼즐의 소요 시간을 `time_prev`, 당신의 숙련도를 `level`이라 하면, 게임은 다음과 같이 진행됩니다.

- `diff` ≤ `level`이면 퍼즐을 틀리지 않고 `time_cur`만큼의 시간을 사용하여 해결합니다.  
- `diff` > `level`이면, 퍼즐을 총 `diff - level`번 틀립니다. 퍼즐을 틀릴 때마다, `time_cur`만큼의 시간을 사용하며, 추가로 `time_prev`만큼의 시간을 사용해 이전 퍼즐을 다시 풀고 와야 합니다. 이전 퍼즐을 다시 풀 때는 이전 퍼즐의 난이도에 상관없이 틀리지 않습니다. `diff - level`번 틀린 이후에 다시 퍼즐을 풀면 `time_cur`만큼의 시간을 사용하여 퍼즐을 해결합니다.

예를 들어 `diff` = 3, `time_cur` = 2, `time_prev` = 4인 경우, `level`에 따라 퍼즐을 푸는데 걸리는 시간은 다음과 같습니다.

- `level` = 1이면, 퍼즐을 3 - 1 = 2번 틀립니다. 한 번 틀릴 때마다 2 + 4 = 6의 시간을 사용하고, 다시 퍼즐을 푸는 데 2의 시간을 사용하므로 총 6 × 2 + 2 = 14의 시간을 사용하게 됩니다.  
- `level` = 2이면, 퍼즐을 3 - 2 = 1번 틀리므로, 6 + 2 = 8의 시간을 사용하게 됩니다.  
- `level` ≥ 3이면 퍼즐을 틀리지 않으며, 2의 시간을 사용하게 됩니다.

퍼즐 게임에는 전체 제한 시간 `limit`가 정해져 있습니다. 제한 시간 내에 퍼즐을 모두 해결하기 위한 숙련도의 최솟값을 구하려고 합니다. 난이도, 소요 시간은 모두 양의 정수며, 숙련도도 양의 정수여야 합니다.

퍼즐의 난이도를 순서대로 담은 1차원 정수 배열 `diffs`, 퍼즐의 소요 시간을 순서대로 담은 1차원 정수 배열 `times`, 전체 제한 시간 `limit`이 매개변수로 주어집니다. 제한 시간 내에 퍼즐을 모두 해결하기 위한 숙련도의 최솟값을 정수로 return 하도록 solution 함수를 완성해 주세요.

---

### 제한사항

- 1 ≤ `diffs`의 길이 = `times`의 길이 = `n` ≤ 300,000  
  - `diffs[i]`는 `i`번째 퍼즐의 난이도, `times[i]`는 `i`번째 퍼즐의 소요 시간입니다.  
  - `diffs[0]` = 1  
  - 1 ≤ `diffs[i]` ≤ 100,000  
  - 1 ≤ `times[i]` ≤ 10,000  
- 1 ≤ `limit` ≤ 10^15  
  - 제한 시간 내에 퍼즐을 모두 해결할 수 있는 경우만 입력으로 주어집니다.

---

### 입출력 예

| diffs                     | times                    | limit      | result |
| ------------------------- | ------------------------ | ---------- | ------ |
| [1, 5, 3]                 | [2, 4, 7]                | 30         | 3      |
| [1, 4, 4, 2]              | [6, 3, 8, 2]             | 59         | 2      |
| [1, 328, 467, 209, 54]    | [2, 7, 1, 4, 3]          | 1723       | 294    |
| [1, 99999, 100000, 99995] | [9999, 9001, 9999, 9001] | 3456789012 | 39354  |

---

### 입출력 예 설명

- 입출력 예 #1  
  숙련도가 3인 경우 다음과 같이 진행됩니다.

  - 1번째 퍼즐을 2의 시간을 사용하여 해결합니다.  
  - 2번째 퍼즐을 5 - 3 = 2번 틀려서 총 (4 + 2) × 2 + 4 = 16의 시간을 사용하여 해결합니다.  
  - 3번째 퍼즐을 7의 시간을 사용하여 해결합니다.  
  
  총 2 + 16 + 7 = 25의 시간을 사용하여 모든 퍼즐을 해결할 수 있습니다. 숙련도가 3보다 작은 경우 제한 시간인 30 이내에 모든 퍼즐을 해결할 수 없습니다.  
  따라서 3을 return 해야 합니다.

- 입출력 예 #2  
  숙련도가 2인 경우 다음과 같이 진행됩니다.

  - 1번째 퍼즐을 6의 시간을 사용하여 해결합니다.  
  - 2번째 퍼즐을 4 - 2 = 2번 틀려서 총 (3 + 6) × 2 + 3 = 21의 시간을 사용하여 해결합니다.  
  - 3번째 퍼즐을 4 - 2 = 2번 틀려서 총 (8 + 3) × 2 + 8 = 30의 시간을 사용하여 해결합니다.  
  - 4번째 퍼즐을 2의 시간을 사용하여 해결합니다.  
  
  총 6 + 21 + 30 + 2 = 59의 시간을 사용하여 모든 퍼즐을 해결할 수 있습니다. 숙련도가 2보다 작은 경우 제한 시간인 59 이내에 모든 퍼즐을 해결할 수 없습니다.  
  따라서 2를 return 해야 합니다.

- 입출력 예 #3  
  숙련도가 294인 경우 다음과 같이 진행됩니다.

  - 1번째 퍼즐을 2의 시간을 사용하여 해결합니다.  
  - 2번째 퍼즐을 328 - 294 = 34번 틀려서 총 (7 + 2) × 34 + 7 = 313의 시간을 사용하여 해결합니다.  
  - 3번째 퍼즐을 467 - 294 = 173번 틀려서 총 (1 + 7) × 173 + 1 = 1385의 시간을 사용하여 해결합니다.  
  - 4번째 퍼즐을 4의 시간을 사용하여 해결합니다.  
  - 5번째 퍼즐을 3의 시간을 사용하여 해결합니다.  
  
  총 2 + 313 + 1,385 + 4 + 3 = 1,707의 시간을 사용하여 모든 퍼즐을 해결할 수 있습니다.  숙련도가 294보다 작은 경우 제한 시간인 1,723 이내에 모든 퍼즐을 해결할 수 없습니다.  
  따라서 294를 return 해야 합니다.

- 입출력 예 #4
  숙련도가 39,354인 경우 다음과 같이 진행됩니다.

  - 1번째 퍼즐을 99,99의 시간을 사용하여 해결합니다.  
  - 2번째 퍼즐을 99,999 - 39,354 = 60,645번 틀려서 총 (9,001 + 9,999) × 60,645 + 9,001 = 1,152,264,001의 시간을 사용하여 해결합니다.  
  - 3번째 퍼즐을 100,000 - 39,354 = 60,646번 틀려서 총 (9,999 + 9,001) × 60,646 + 9,999 = 1,152,283,999의 시간을 사용하여 해결합니다.  
  - 4번째 퍼즐을 99,995 - 39,354 = 60,641번 틀려서 총 (9,001 + 9,999) × 60,641 + 9,001 = 1,152,188,001의 시간을 사용하여 해결합니다.  
  
  총 9,999 + 1,152,264,001 + 1,152,283,999 + 1,152,188,001 = 3,456,746,000의 시간을 사용하여 모든 퍼즐을 해결할 수 있습니다. 숙련도가 39,354보다 작은 경우 제한 시간인 3,456,789,012 이내에 모든 퍼즐을 해결할 수 없습니다.  
  따라서 39,354를 return 해야 합니다.

---

### 풀이과정

- 구해야 하는 값은 **제한시간 내에 모든 퍼즐을 풀 수 있는 숙련도의 최소값**  
- 직관적으로 떠오른 선형탐색의 경우 숙련도를 1부터 최대난이도(`max(diffs)`)까지 탐색해서 찾게되는데  
  최선의 경우(찾는값이 첫번째 원소에 있는경우) `O(1)` 이지만, 최악의 경우 리스트의 길이 `n`만큼 비례하게 증가 (`O(n)`)  
- 숙련도가 증가할수록 퍼즐을 푸는 데 소요하는 시간은 줄어들거나 일정하게 유지된다. 단조성을 가지고 있고, 최소숙련도만 찾으면 되는 문제이기 때문에 이진탐색을 활용하여 최소숙련도를 탐색  
  최선의 경우(찾는 값이 첫번째 원소에 있는경우) `O(1)`  
  최악의 경우 `O(logN)`, `N`은 탐색해야할 범위
  > 리스트의 길이가 10일 때, 10 -> 5 -> 3 -> 2  
  > 리스트의 길이가 1,000일 떄, 1,000 -> 500 -> 250 -> 125 -> 62 -> 31 -> 15 -> 7 -> 3 -> 1

(1) 숙련도의 최소값(`left`)과 최대값(`right`)의 범위 내에서 중앙값(`mid`)을 계산하고 퍼즐을 풀 수 있는지 확인.  
(2) 중앙값(`mid`)으로 제한시간 내에 퍼즐을 풀 수 있다면 더 작은 숙련도를 찾아야 하므로 최대값(`right`)을 중앙값(`mid`)으로 갱신. 제한시간 내에 퍼즐을 풀 수 없다면 더 높은 숙련도를 찾아야 하므로 최소값(`left`)을 `mid+1`로 갱신

```python
def solution(diffs, times, limit):
    # 퍼즐을 주어진 level로 풀 때 필요한 총 시간을 계산
    def time_needed(level):
        total_time = 0  # 총 소요시간을 0으로
        prev_time = 0   # 이전 퍼즐의 소요시간을 0으로
        
        # 각 퍼즐에 대해 시간 계산
        for i in range(len(diffs)):
            diff_i = diffs[i]     # 난이도
            time_cur_i = times[i] # i번째 퍼즐의 소요시간
            
            # 퍼즐을 틀리지 않고 풀 수 있다면
            if diff_i <= level:
                # 총 소요시간에 i번째 퍼즐의 소요시간을 더함
                total_time += time_cur_i
            else:
                # 퍼즐을 틀린 횟수: diff - level
                wrong_count = diff_i - level
                # 틀린 만큼 시간 소요 (틀릴 때마다 i번째 퍼즐의 소요시간(time_cur) + 이전 퍼즐 소요시간 (prev_time)소모)
                total_time += wrong_count * (time_cur_i + prev_time) + time_cur_i
            
            prev_time = time_cur_i  # 현재 퍼즐의 시간을 이전 퍼즐 시간으로 설정
            
            # 만약 제한 시간을 초과하면 바로 리턴
            if total_time > limit:
                return total_time
        
        return total_time  # 최종적으로 계산된 총 소요 시간 리턴
    
    # 이진 탐색 범위 설정
    left, right = 1, max(diffs)  # 숙련도 level은 1부터 시작하고, 최대는 diffs의 최대값
    
    # 이진 탐색을 사용하여 최적의 level을 찾음
    while left < right:
        mid = (left + right) // 2  # 중간값 계산
        # mid 레벨로 모든 퍼즐을 풀 수 있는지 확인
        if time_needed(mid) <= limit:
            right = mid  # 제한 시간 내에 풀 수 있으면 더 작은 level을 시도
        else:
            left = mid + 1  # 제한 시간 초과 시, 더 큰 level을 시도
    
    return left
```