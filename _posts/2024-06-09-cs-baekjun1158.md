---
layout: post
title: "[백준]1159번 요세푸스 문제(Python3)"
date: 2024-06-09 20:00:00 +0900
categories: [CS, 백준]
tags: [CS, 백준]
author: "ADG"
---

# 문제

요세푸스 문제는 다음과 같다.

1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 <3, 6, 2, 7, 5, 1, 4>이다.

N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.

---

### 입력

첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 5,000)

---

### 출력

예제와 같이 요세푸스 순열을 출력한다.

---

### 예제 입력 1

7 3

---

### 예제 출력 1

<3, 6, 2, 7, 5, 1, 4>

---

### 시행착오

- 처음 시도한 방식 : 원을 이루는 사람들의 리스트에서 순차적으로 `K`번째 사람을 제거하는 방식으로 접근  
  
  ```python
  # 예시
  N, K = 7, 3
  target = list(range(1, N + 1))
  res = []

  while target:
    Kth_person = (K - 1) % len(target) # K 번쨰 사람의 인덱스
    res.append(target.pop(Kth_person)) # K 번째 사람을 리스트에서 제거
  ```

---

### 개선해야 할 사항

- 리스트에서의 `pop()`연산은 원소를 삭제하기 위해 그 뒤에 있는 모든 원소들을 앞으로 한 칸씩 밀어야 하기 때문에 `O(n)`의 시간복잡도를 가진다.  
- `target.pop(Kth_person)`을 수행하기 위해 K 번째 사람을 제거한 뒤 리스트를 재정렬하며 `O(n)`의 시간이 소요된다.  
- 리스트의 크기가 `N`일 경우를 생각해보면  
  >(1) 첫번째 사람을 제거하고 리스트를 재정렬 함 : `O(N-1)`  
  >(2) 두번째 사람을 제거하고 리스트를 재정렬 함 : `O(N-2)`  
  >(3) ...  
  >(4) 전체 시간 복잡도는  
  >
  >`O((N-1)` + `O(N-2)` + `O(N-3)` + ... + `O(1)` = `O(N^2)`

- 개선 : 리스트에서 `pop()` 연산을 사용하는 경우 원소를 제거하고 원소를 이동시키는 과정에서 메모리 할당 비용이 발생하게 된다.  
  
  (1) `deque` 자료구조를 사용하여 `pop()`연산을 통해 원소를 제거하는데 `O(1)`의 시간복잡도를 사용  

  (2) `rotate()`를 사용하면 원소를 물리적으로 이동시키지 않고, 포인터(인덱스)만 재배치하여 순서를 변경하기 때문에 메모리 할당에 대한 추가적인 비용 발생이 없다.

  ```python
  from collections import deque

  N = 7
  queue = deque(range(1, N + 1))
  print(queue) # deque([1, 2, 3, 4, 5, 6, 7])

  queue.rotate(1)
  print(queue) # deque([7, 1, 2, 3, 4, 5, 6])
  ```

---

### 풀이

- 원을 구성하는 사람들을 `deque`에 저장
- `rotate(-(K - 1))`을 수행하여 `K`번째 사람이 맨 앞에 오도록 조정
- `popleft()`를 수행하여 맨 앞으로 이동한 `K`번째 사람 제거

```python
from collections import deque

# 입력 받기
N, K = map(int, input().split())

# 사람들을 1부터 N까지 큐에 넣음
queue = deque(range(1, N+1))

result = []

# 요세푸스 순열 구하기
while queue:
    # K-1 만큼 회전한 후, K번째 사람을 제거
    queue.rotate(-(K-1))
    result.append(queue.popleft())

# 출력 형식 맞추기
print("<" + ", ".join(map(str, result)) + ">")
```